/**
 * VALIDADOR DE PAGAMENTOS PIX - VERS√ÉO CORRIGIDA
 * Aplica as 5 situa√ß√µes de valida√ß√£o com verifica√ß√£o REAL no banco de dados
 */

// URL do JSON Server (backend) - ajuste a porta se necess√°rio
const DB_API_URL = 'http://localhost:3000/transactions';

/**
 * Verifica se transa√ß√£o j√° existe NO BANCO DE DADOS
 */
const checkTransactionInDatabase = async (transactionId) => {
  try {
    console.log('üîç Verificando transa√ß√£o no banco:', transactionId);
    
    const response = await fetch(`${DB_API_URL}?transactionId=${encodeURIComponent(transactionId)}`);
    
    if (!response.ok) {
      console.warn('‚ö†Ô∏è Banco de dados offline, usando fallback local');
      // Fallback para localStorage se o banco estiver offline
      const localTransactions = JSON.parse(localStorage.getItem('processedPixTransactions') || '[]');
      return localTransactions.includes(transactionId);
    }
    
    const transactions = await response.json();
    
    console.log('üìä Transa√ß√µes encontradas:', transactions.length);
    
    // Se j√° existe uma transa√ß√£o com este ID
    return transactions.length > 0;
    
  } catch (error) {
    console.error('‚ùå Erro ao verificar banco de dados:', error);
    
    // Fallback: verificar no localStorage
    try {
      const localTransactions = JSON.parse(localStorage.getItem('processedPixTransactions') || '[]');
      return localTransactions.includes(transactionId);
    } catch (localError) {
      console.error('‚ùå Erro no fallback:', localError);
    }
    
    // Por seguran√ßa, em caso de erro, assumir que existe (evita duplica√ß√£o)
    return true;
  }
};

/**
 * Registra transa√ß√£o NO BANCO DE DADOS
 */
const registerTransactionInDatabase = async (transactionData) => {
  try {
    console.log('üìù Registrando transa√ß√£o no banco:', transactionData.transactionId);
    
    const hoje = new Date().toISOString().split('T')[0];
    
    const transactionRecord = {
      transactionId: transactionData.transactionId,
      beneficiary: transactionData.beneficiary || 'GUSTAVO SANTOS RIBEIRO',
      amount: parseFloat(transactionData.amount) || 10.00,
      paymentDate: transactionData.date || hoje,
      createdAt: new Date().toISOString(),
      status: 'APROVADO',
      validatedAt: new Date().toISOString()
    };
    
    const response = await fetch(DB_API_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(transactionRecord)
    });
    
    if (!response.ok) {
      throw new Error(`Erro HTTP: ${response.status}`);
    }
    
    const result = await response.json();
    console.log('‚úÖ Transa√ß√£o registrada no banco com ID:', result.id);
    
    // Tamb√©m salvar localmente como backup
    try {
      const localTransactions = JSON.parse(localStorage.getItem('processedPixTransactions') || '[]');
      if (!localTransactions.includes(transactionData.transactionId)) {
        localTransactions.push(transactionData.transactionId);
        localStorage.setItem('processedPixTransactions', JSON.stringify(localTransactions));
        console.log('üíæ Backup salvo no localStorage');
      }
    } catch (localError) {
      console.warn('‚ö†Ô∏è N√£o foi poss√≠vel salvar no localStorage:', localError);
    }
    
    return result;
    
  } catch (error) {
    console.error('‚ùå Erro ao registrar transa√ß√£o no banco:', error);
    
    // Fallback: salvar apenas localmente
    try {
      const localTransactions = JSON.parse(localStorage.getItem('processedPixTransactions') || '[]');
      if (!localTransactions.includes(transactionData.transactionId)) {
        localTransactions.push(transactionData.transactionId);
        localStorage.setItem('processedPixTransactions', JSON.stringify(localTransactions));
        console.log('üíæ Transa√ß√£o salva apenas localmente (fallback)');
      }
    } catch (localError) {
      console.error('‚ùå Erro no fallback local:', localError);
    }
    
    return null;
  }
};

/**
 * Valida um pagamento PIX - VERS√ÉO CORRIGIDA
 * @param {Object} paymentData - Dados do pagamento
 * @returns {Object} Resultado da valida√ß√£o
 */
export const validatePayment = async (paymentData) => {
  try {
    console.log('üîç Validando pagamento:', paymentData);
    
    const hoje = new Date().toISOString().split('T')[0];
    const valorMinimo = 10.00; // VALOR CORRIGIDO: R$ 10,00
    
    // Converter amount para n√∫mero
    const valor = parseFloat(paymentData.amount);
    
    // ============================================
    // SITUA√á√ÉO 1: TRANS√á√ÉO DUPLICADA (AGORA NO BANCO)
    // ============================================
    const isDuplicate = await checkTransactionInDatabase(paymentData.transactionId);
    
    if (isDuplicate) {
      console.log('‚ùå Situa√ß√£o 1: Transa√ß√£o duplicada no banco');
      return {
        approved: false,
        message: 'RECUSADO: Transa√ß√£o j√° utilizada',
        details: 'Este comprovante PIX j√° foi usado anteriormente. ID: ' + paymentData.transactionId,
        situation: 1,
        timestamp: new Date().toISOString()
      };
    }
    
    // ============================================
    // SITUA√á√ÉO 2: NOME DO FAVORECIDO INCORRETO
    // ============================================
    const nomeCorreto = 'GUSTAVO SANTOS RIBEIRO';
    if (paymentData.beneficiary !== nomeCorreto) {
      console.log('‚ùå Situa√ß√£o 2: Nome do favorecido incorreto');
      return {
        approved: false,
        message: 'RECUSADO: Nome incorreto',
        details: `Nome do favorecido n√£o corresponde. Deve ser: ${nomeCorreto}`,
        situation: 2,
        timestamp: new Date().toISOString()
      };
    }
    
    // ============================================
    // SITUA√á√ÉO 3: VALOR M√çNIMO N√ÉO ATINGIDO
    // ============================================
    if (valor < valorMinimo) {
      console.log('‚ùå Situa√ß√£o 3: Valor m√≠nimo n√£o atingido');
      return {
        approved: false,
        message: 'RECUSADO: Valor insuficiente',
        details: `Valor m√≠nimo n√£o atingido. M√≠nimo: R$ ${valorMinimo.toFixed(2)}`,
        situation: 3,
        timestamp: new Date().toISOString()
      };
    }
    
    // ============================================
    // SITUA√á√ÉO 4: DATA DIFERENTE DA ATUAL
    // ============================================
    if (paymentData.date !== hoje) {
      console.log('‚ùå Situa√ß√£o 4: Data diferente da atual');
      return {
        approved: false,
        message: 'RECUSADO: Data incorreta',
        details: `Data da transa√ß√£o n√£o √© a data atual. Data do comprovante: ${paymentData.date}, Data atual: ${hoje}`,
        situation: 4,
        timestamp: new Date().toISOString()
      };
    }
    
    // ============================================
    // SITUA√á√ÉO 5: TUDO OK - APROVADO
    // ============================================
    console.log('‚úÖ Situa√ß√£o 5: Tudo OK - Pagamento aprovado');
    
    // ‚úÖ CORRE√á√ÉO: Registrar transa√ß√£o NO BANCO DE DADOS
    await registerTransactionInDatabase(paymentData);
    
    return {
      approved: true,
      message: 'APROVADO: Pagamento validado',
      details: 'Comprovante aprovado em todas as verifica√ß√µes. Consulta liberada!',
      situation: 5,
      timestamp: new Date().toISOString(),
      transactionId: paymentData.transactionId,
      approvedAmount: valor
    };
    
  } catch (error) {
    console.error('üí• Erro na valida√ß√£o:', error);
    return {
      approved: false,
      message: 'ERRO: Valida√ß√£o falhou',
      details: `Erro t√©cnico: ${error.message}`,
      situation: 'error',
      timestamp: new Date().toISOString()
    };
  }
};

/**
 * Limpar transa√ß√µes processadas (para testes)
 */
export const clearProcessedTransactions = () => {
  // Limpar localStorage
  localStorage.removeItem('processedPixTransactions');
  console.log('üßπ Transa√ß√µes locais limpas');
  
  // Nota: Para limpar o banco, precisa de API espec√≠fica
};

// Exportar tamb√©m como padr√£o para compatibilidade
export default validatePayment;
