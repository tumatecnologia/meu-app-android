// src/services/paymentControl.js - VERS√ÉO SIMPLIFICADA

class PaymentControlService {
  
  // CONDI√á√ÉO 1: Data EXATAMENTE igual a hoje
  static isToday(dateString) {
    try {
      const hoje = new Date();
      const dia = String(hoje.getDate()).padStart(2, '0');
      const mes = String(hoje.getMonth() + 1).padStart(2, '0');
      const hojeFormatado = `${dia}/${mes}`;
      
      // Aceitar DD.MM ou DD/MM
      const dataNormalizada = dateString.replace('.', '/');
      const valido = dataNormalizada === hojeFormatado;
      
      console.log(`[1] Data: ${dataNormalizada} = ${hojeFormatado}? ${valido ? '‚úÖ' : '‚ùå'}`);
      return valido;
    } catch (error) {
      console.error('Erro data:', error);
      return false;
    }
  }
  
  // CONDI√á√ÉO 2: Hora ‚â§ 5 minutos
  static isWithin5Minutes(timeString) {
    try {
      const agora = new Date();
      const agoraMin = agora.getHours() * 60 + agora.getMinutes();
      
      // Aceitar HH.MM ou HH:MM
      const horaNormalizada = timeString.replace('.', ':');
      const [hora, minuto] = horaNormalizada.split(':').map(Number);
      const compMin = hora * 60 + minuto;
      
      const diferenca = agoraMin - compMin;
      const valido = diferenca >= 0 && diferenca <= 5;
      
      console.log(`[2] Hora: ${horaNormalizada}, Dif: ${diferenca}min? ${valido ? '‚úÖ' : '‚ùå'}`);
      return valido;
    } catch (error) {
      console.error('Erro hora:', error);
      return false;
    }
  }
  
  // CONDI√á√ÉO 3: Nome correto
  static isValidBeneficiary(beneficiary) {
    const nomesValidos = [
      "Gustavo Santos Ribeiro",
      "Gustavo S Ribeiro"
    ];
    
    const nomeLimpo = beneficiary.trim();
    const valido = nomesValidos.some(n => 
      n.toLowerCase() === nomeLimpo.toLowerCase()
    );
    
    console.log(`[3] Nome: "${nomeLimpo}"? ${valido ? '‚úÖ' : '‚ùå'}`);
    return valido;
  }
  
  // CONDI√á√ÉO 4: Valor R$ 10,00
  static isValidAmount(amount) {
    const valido = Math.abs(amount - 10.00) < 0.01;
    console.log(`[4] Valor: R$ ${amount.toFixed(2)} = R$ 10,00? ${valido ? '‚úÖ' : '‚ùå'}`);
    return valido;
  }
  
  // CONDI√á√ÉO 5: N√£o duplicado
  static isDuplicatePayment(paymentData) {
    try {
      const db = JSON.parse(localStorage.getItem('tarot_payments_db') || '[]');
      const duplicado = db.some(r => 
        r.date === paymentData.date &&
        r.time === paymentData.time &&
        Math.abs(r.amount - paymentData.amount) < 0.01 &&
        r.beneficiary.toLowerCase() === paymentData.beneficiary.toLowerCase()
      );
      
      console.log(`[5] Duplicado? ${duplicado ? '‚ùå' : '‚úÖ'}`);
      return duplicado;
    } catch (error) {
      console.error('Erro duplicidade:', error);
      return false;
    }
  }
  // EXTRAIR DADOS - VERS√ÉO SIMPLES
  static extractPaymentData(fileName) {
    console.log('üìÑ Arquivo:', fileName);
    
    try {
      // Remover extens√£o
      const nomeSemExt = fileName.split('.').slice(0, -1).join('.');
      const partes = nomeSemExt.split(/[_\-\s]+/);
      
      console.log('Partes:', partes);
      
      // Procurar padr√£o DD.MM ou DD/MM
      let data = '';
      let hora = '';
      let nomeInicio = 0;
      
      for (let i = 0; i < partes.length; i++) {
        if (partes[i].match(/^\d{1,2}[\.\/]\d{1,2}$/)) {
          data = partes[i];
          
          // Pr√≥xima parte deve ser hora
          if (i + 1 < partes.length && partes[i + 1].match(/^\d{1,2}[\.\:]\d{1,2}$/)) {
            hora = partes[i + 1];
            nomeInicio = i + 2;
            break;
          }
        }
      }
      
      if (!data || !hora) {
        throw new Error('Data ou hora n√£o encontrada');
      }
      
      // Nome s√£o todas as partes at√© o pen√∫ltimo
      const nomeParts = [];
      for (let i = nomeInicio; i < partes.length - 1; i++) {
        // Parar se encontrar n√∫mero (poss√≠vel valor)
        if (partes[i].match(/^\d+\.?\d*$/)) break;
        nomeParts.push(partes[i]);
      }
      
      const nome = nomeParts.join(' ');
      const valor = parseFloat(partes[partes.length - 1]);
      
      if (isNaN(valor)) {
        throw new Error('Valor inv√°lido');
      }
      
      const dados = {
        date: data.replace('.', '/'),
        time: hora.replace('.', ':'),
        beneficiary: nome,
        amount: valor,
        fileName: fileName
      };
      
      console.log('üì¶ Extra√≠do:', dados);
      return dados;
    } catch (error) {
      console.error('‚ùå Erro extra√ß√£o:', error);
      throw new Error(`Formato: data_hora_nome_10.00. Ex: "07.12_18.05_Gustavo Santos Ribeiro_10.00.jpg"`);
    }
  }
  
  // SALVAR
  static savePaymentToDatabase(paymentData) {
    const registro = {
      id: `pix_${Date.now()}`,
      timestamp: new Date().toISOString(),
      date: paymentData.date,
      time: paymentData.time,
      beneficiary: paymentData.beneficiary,
      amount: paymentData.amount,
      fileName: paymentData.fileName,
      status: 'validated',
      readingAccessed: false
    };
    
    const db = JSON.parse(localStorage.getItem('tarot_payments_db') || '[]');
    db.push(registro);
    localStorage.setItem('tarot_payments_db', JSON.stringify(db));
    
    console.log('üíæ Salvo:', registro.id);
    return registro;
  }
  // PROCESSAR
  static async processarArquivo(file) {
    console.log('='.repeat(50));
    console.log('üîÑ VALIDA√á√ÉO PIX');
    console.log('='.repeat(50));
    
    try {
      const paymentData = this.extractPaymentData(file.name);
      
      const condicoes = {
        dataHoje: this.isToday(paymentData.date),
        dentro5min: this.isWithin5Minutes(paymentData.time),
        nomeExato: this.isValidBeneficiary(paymentData.beneficiary),
        valorExato: this.isValidAmount(paymentData.amount),
        naoDuplicado: !this.isDuplicatePayment(paymentData)
      };
      
      console.log('='.repeat(50));
      console.log('üìä RESULTADO:');
      Object.entries(condicoes).forEach(([k, v]) => {
        console.log(`  ${k}: ${v ? '‚úÖ' : '‚ùå'}`);
      });
      console.log('='.repeat(50));
      
      const todasValidas = Object.values(condicoes).every(v => v === true);
      
      if (!todasValidas) {
        const falsas = Object.keys(condicoes).filter(k => !condicoes[k]);
        return {
          valido: false,
          mensagem: "‚ùå Comprovante inv√°lido. Fa√ßa novo pagamento.",
          detalhes: condicoes
        };
      }
      
      const registro = this.savePaymentToDatabase(paymentData);
      
      return {
        valido: true,
        mensagem: "‚úÖ Pagamento validado! Liberando consulta...",
        paymentId: registro.id
      };
      
    } catch (error) {
      console.error('‚ùå ERRO:', error);
      return {
        valido: false,
        mensagem: `‚ùå ${error.message}`
      };
    }
  }
  
  // OUTRAS FUN√á√ïES
  static checkReadingAccess() {
    try {
      const db = JSON.parse(localStorage.getItem('tarot_payments_db') || '[]');
      return db.find(p => p.status === 'validated' && !p.readingAccessed) || null;
    } catch (error) {
      console.error('Erro acesso:', error);
      return null;
    }
  }
  
  static markReadingAsAccessed(paymentId) {
    try {
      const db = JSON.parse(localStorage.getItem('tarot_payments_db') || '[]');
      const novoDb = db.map(p => 
        p.id === paymentId ? { ...p, readingAccessed: true } : p
      );
      localStorage.setItem('tarot_payments_db', JSON.stringify(novoDb));
      return true;
    } catch (error) {
      console.error('Erro marcando:', error);
      return false;
    }
  }
  
  static clearDatabase() {
    localStorage.removeItem('tarot_payments_db');
    console.log('üßπ Limpo!');
  }
  
  static getAllPayments() {
    try {
      return JSON.parse(localStorage.getItem('tarot_payments_db') || '[]');
    } catch (error) {
      console.error('Erro listando:', error);
      return [];
    }
  }
}

export default PaymentControlService;
